<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>OGR2GUI x64: include/ogr/cpl_virtualmem.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">OGR2GUI x64
   &#160;<span id="projectnumber">0.7</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_4d5203630685a6013c8de9e27085a9fc.html">ogr</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">cpl_virtualmem.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="cpl__port_8h_source.html">cpl_port.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="cpl__vsi_8h_source.html">cpl_vsi.h</a>&quot;</code><br />
</div>
<p><a href="cpl__virtualmem_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aac693188a82d797c5a651f275fddab82"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a></td></tr>
<tr class="separator:aac693188a82d797c5a651f275fddab82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575c56435cea278a5bf98bf2c21e7b8f"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#a575c56435cea278a5bf98bf2c21e7b8f">CPLVirtualMemCachePageCbk</a> )(<a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *ctxt, size_t nOffset, void *pPageToFill, size_t nToFill, void *pUserData)</td></tr>
<tr class="separator:a575c56435cea278a5bf98bf2c21e7b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0c6ca7bd8ad956b6f62faefdcc5b66"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#aec0c6ca7bd8ad956b6f62faefdcc5b66">CPLVirtualMemUnCachePageCbk</a> )(<a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *ctxt, size_t nOffset, const void *pPageToBeEvicted, size_t nToBeEvicted, void *pUserData)</td></tr>
<tr class="separator:aec0c6ca7bd8ad956b6f62faefdcc5b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9d54d83138551ff3067d8e23d8448c"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#aba9d54d83138551ff3067d8e23d8448c">CPLVirtualMemFreeUserData</a> )(void *pUserData)</td></tr>
<tr class="separator:aba9d54d83138551ff3067d8e23d8448c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aeba7fc305d946740f9e88513220c73a1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#aeba7fc305d946740f9e88513220c73a1">CPLVirtualMemAccessMode</a> { <a class="el" href="cpl__virtualmem_8h.html#aeba7fc305d946740f9e88513220c73a1ac449c40cb0760b72f362e2cf4cd3da79">VIRTUALMEM_READONLY</a>, 
<a class="el" href="cpl__virtualmem_8h.html#aeba7fc305d946740f9e88513220c73a1a67628910ddcd5816bf230061adc45d97">VIRTUALMEM_READONLY_ENFORCED</a>, 
<a class="el" href="cpl__virtualmem_8h.html#aeba7fc305d946740f9e88513220c73a1aa6486140a01b52ef723a17a39f9e1169">VIRTUALMEM_READWRITE</a>
 }</td></tr>
<tr class="separator:aeba7fc305d946740f9e88513220c73a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1fda6753fc13f3dc348605da8bce9c2f"><td class="memItemLeft" align="right" valign="top">size_t <a class="el" href="cpl__port_8h.html#a42f5fd9b9df7d179918990cd3d7d6783">CPL_DLL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#a1fda6753fc13f3dc348605da8bce9c2f">CPLGetPageSize</a> (void)</td></tr>
<tr class="separator:a1fda6753fc13f3dc348605da8bce9c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab2ce94850ef31458c65cb16ce828dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> <a class="el" href="cpl__port_8h.html#a42f5fd9b9df7d179918990cd3d7d6783">CPL_DLL</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#a3ab2ce94850ef31458c65cb16ce828dc">CPLVirtualMemNew</a> (size_t nSize, size_t nCacheSize, size_t nPageSizeHint, <a class="el" href="cpl__progress_8h.html#aae7d79c99462ba26b884decdbab4724d">int</a> bSingleThreadUsage, <a class="el" href="cpl__virtualmem_8h.html#aeba7fc305d946740f9e88513220c73a1">CPLVirtualMemAccessMode</a> eAccessMode, <a class="el" href="cpl__virtualmem_8h.html#a575c56435cea278a5bf98bf2c21e7b8f">CPLVirtualMemCachePageCbk</a> pfnCachePage, <a class="el" href="cpl__virtualmem_8h.html#aec0c6ca7bd8ad956b6f62faefdcc5b66">CPLVirtualMemUnCachePageCbk</a> pfnUnCachePage, <a class="el" href="cpl__virtualmem_8h.html#aba9d54d83138551ff3067d8e23d8448c">CPLVirtualMemFreeUserData</a> pfnFreeUserData, void *pCbkUserData)</td></tr>
<tr class="separator:a3ab2ce94850ef31458c65cb16ce828dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23dca3961c27fceab73cb5b568c0e847"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__progress_8h.html#aae7d79c99462ba26b884decdbab4724d">int</a> <a class="el" href="cpl__port_8h.html#a42f5fd9b9df7d179918990cd3d7d6783">CPL_DLL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#a23dca3961c27fceab73cb5b568c0e847">CPLIsVirtualMemFileMapAvailable</a> (void)</td></tr>
<tr class="separator:a23dca3961c27fceab73cb5b568c0e847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5109bc5b902ac637da108a8a4f7a2594"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> <a class="el" href="cpl__port_8h.html#a42f5fd9b9df7d179918990cd3d7d6783">CPL_DLL</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#a5109bc5b902ac637da108a8a4f7a2594">CPLVirtualMemFileMapNew</a> (<a class="el" href="cpl__vsi_8h.html#af1b1400e402360b38304de2b13d16c14">VSILFILE</a> *fp, <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> nOffset, <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> nLength, <a class="el" href="cpl__virtualmem_8h.html#aeba7fc305d946740f9e88513220c73a1">CPLVirtualMemAccessMode</a> eAccessMode, <a class="el" href="cpl__virtualmem_8h.html#aba9d54d83138551ff3067d8e23d8448c">CPLVirtualMemFreeUserData</a> pfnFreeUserData, void *pCbkUserData)</td></tr>
<tr class="separator:a5109bc5b902ac637da108a8a4f7a2594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa23ac6c1b9b0f185cc73a9c320180c9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> <a class="el" href="cpl__port_8h.html#a42f5fd9b9df7d179918990cd3d7d6783">CPL_DLL</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#aa23ac6c1b9b0f185cc73a9c320180c9c">CPLVirtualMemDerivedNew</a> (<a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *pVMemBase, <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> nOffset, <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> nSize, <a class="el" href="cpl__virtualmem_8h.html#aba9d54d83138551ff3067d8e23d8448c">CPLVirtualMemFreeUserData</a> pfnFreeUserData, void *pCbkUserData)</td></tr>
<tr class="separator:aa23ac6c1b9b0f185cc73a9c320180c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733490834e65cac877b01007e51f08cb"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="cpl__port_8h.html#a42f5fd9b9df7d179918990cd3d7d6783">CPL_DLL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#a733490834e65cac877b01007e51f08cb">CPLVirtualMemFree</a> (<a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *ctxt)</td></tr>
<tr class="separator:a733490834e65cac877b01007e51f08cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a74f5d89021660d2352eb17d1113fc"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="cpl__port_8h.html#a42f5fd9b9df7d179918990cd3d7d6783">CPL_DLL</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#a25a74f5d89021660d2352eb17d1113fc">CPLVirtualMemGetAddr</a> (<a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *ctxt)</td></tr>
<tr class="separator:a25a74f5d89021660d2352eb17d1113fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4203d033bae8e3810f0e0f9f64741429"><td class="memItemLeft" align="right" valign="top">size_t <a class="el" href="cpl__port_8h.html#a42f5fd9b9df7d179918990cd3d7d6783">CPL_DLL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#a4203d033bae8e3810f0e0f9f64741429">CPLVirtualMemGetSize</a> (<a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *ctxt)</td></tr>
<tr class="separator:a4203d033bae8e3810f0e0f9f64741429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba5873a189dc59339c85c46499202d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__progress_8h.html#aae7d79c99462ba26b884decdbab4724d">int</a> <a class="el" href="cpl__port_8h.html#a42f5fd9b9df7d179918990cd3d7d6783">CPL_DLL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#aaba5873a189dc59339c85c46499202d5">CPLVirtualMemIsFileMapping</a> (<a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *ctxt)</td></tr>
<tr class="separator:aaba5873a189dc59339c85c46499202d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0565635f915e3108d531194cc509def6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__virtualmem_8h.html#aeba7fc305d946740f9e88513220c73a1">CPLVirtualMemAccessMode</a> <a class="el" href="cpl__port_8h.html#a42f5fd9b9df7d179918990cd3d7d6783">CPL_DLL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#a0565635f915e3108d531194cc509def6">CPLVirtualMemGetAccessMode</a> (<a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *ctxt)</td></tr>
<tr class="separator:a0565635f915e3108d531194cc509def6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8fe1e9ab81d048c39655ebeb3fbc504"><td class="memItemLeft" align="right" valign="top">size_t <a class="el" href="cpl__port_8h.html#a42f5fd9b9df7d179918990cd3d7d6783">CPL_DLL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#ad8fe1e9ab81d048c39655ebeb3fbc504">CPLVirtualMemGetPageSize</a> (<a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *ctxt)</td></tr>
<tr class="separator:ad8fe1e9ab81d048c39655ebeb3fbc504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc227f9b7237e7a4ca7b284affffb98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__progress_8h.html#aae7d79c99462ba26b884decdbab4724d">int</a> <a class="el" href="cpl__port_8h.html#a42f5fd9b9df7d179918990cd3d7d6783">CPL_DLL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#aebc227f9b7237e7a4ca7b284affffb98">CPLVirtualMemIsAccessThreadSafe</a> (<a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *ctxt)</td></tr>
<tr class="separator:aebc227f9b7237e7a4ca7b284affffb98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab02ca8df117924498e82dd4baaf6e1f7"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="cpl__port_8h.html#a42f5fd9b9df7d179918990cd3d7d6783">CPL_DLL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#ab02ca8df117924498e82dd4baaf6e1f7">CPLVirtualMemDeclareThread</a> (<a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *ctxt)</td></tr>
<tr class="separator:ab02ca8df117924498e82dd4baaf6e1f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341e2a12a981a724b0a577a891e993f9"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="cpl__port_8h.html#a42f5fd9b9df7d179918990cd3d7d6783">CPL_DLL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#a341e2a12a981a724b0a577a891e993f9">CPLVirtualMemUnDeclareThread</a> (<a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *ctxt)</td></tr>
<tr class="separator:a341e2a12a981a724b0a577a891e993f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f5d5276f1cbe4c77637977476349f5"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="cpl__port_8h.html#a42f5fd9b9df7d179918990cd3d7d6783">CPL_DLL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#ad5f5d5276f1cbe4c77637977476349f5">CPLVirtualMemPin</a> (<a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *ctxt, void *pAddr, size_t nSize, <a class="el" href="cpl__progress_8h.html#aae7d79c99462ba26b884decdbab4724d">int</a> bWriteOp)</td></tr>
<tr class="separator:ad5f5d5276f1cbe4c77637977476349f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aec86ac68ec821d1d48776a263fa0a4"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="cpl__port_8h.html#a42f5fd9b9df7d179918990cd3d7d6783">CPL_DLL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__virtualmem_8h.html#a0aec86ac68ec821d1d48776a263fa0a4">CPLVirtualMemManagerTerminate</a> (void)</td></tr>
<tr class="separator:a0aec86ac68ec821d1d48776a263fa0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Virtual memory management.</p>
<p>This file provides mechanism to define virtual memory mappings, whose content is allocated transparently and filled on-the-fly. Those virtual memory mappings can be much larger than the available RAM, but only parts of the virtual memory mapping, in the limit of the allowed the cache size, will actually be physically allocated.</p>
<p>This exploits low-level mechanisms of the operating system (virtual memory allocation, page protection and handler of virtual memory exceptions).</p>
<p>It is also possible to create a virtual memory mapping from a file or part of a file.</p>
<p>The current implementation is Linux only. </p>

<p>Definition in file <a class="el" href="cpl__virtualmem_8h_source.html">cpl_virtualmem.h</a>.</p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="aac693188a82d797c5a651f275fddab82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> <a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opaque type that represents a virtual memory mapping. </p>

<p>Definition at line <a class="el" href="cpl__virtualmem_8h_source.html#l00060">60</a> of file <a class="el" href="cpl__virtualmem_8h_source.html">cpl_virtualmem.h</a>.</p>

</div>
</div>
<a class="anchor" id="a575c56435cea278a5bf98bf2c21e7b8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* CPLVirtualMemCachePageCbk)(<a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *ctxt, size_t nOffset, void *pPageToFill, size_t nToFill, void *pUserData)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback triggered when a still unmapped page of virtual memory is accessed. The callback has the responsibility of filling the page with relevant values</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctxt</td><td>virtual memory handle. </td></tr>
    <tr><td class="paramname">nOffset</td><td>offset of the page in the memory mapping. </td></tr>
    <tr><td class="paramname">pPageToFill</td><td>address of the page to fill. Note that the address might be a temporary location, and not at <a class="el" href="cpl__virtualmem_8h.html#a25a74f5d89021660d2352eb17d1113fc">CPLVirtualMemGetAddr()</a> + nOffset. </td></tr>
    <tr><td class="paramname">nToFill</td><td>number of bytes of the page. </td></tr>
    <tr><td class="paramname">pUserData</td><td>user data that was passed to <a class="el" href="cpl__virtualmem_8h.html#a3ab2ce94850ef31458c65cb16ce828dc">CPLVirtualMemNew()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cpl__virtualmem_8h_source.html#l00072">72</a> of file <a class="el" href="cpl__virtualmem_8h_source.html">cpl_virtualmem.h</a>.</p>

</div>
</div>
<a class="anchor" id="aba9d54d83138551ff3067d8e23d8448c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* CPLVirtualMemFreeUserData)(void *pUserData)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback triggered when a virtual memory mapping is destroyed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUserData</td><td>user data that was passed to <a class="el" href="cpl__virtualmem_8h.html#a3ab2ce94850ef31458c65cb16ce828dc">CPLVirtualMemNew()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cpl__virtualmem_8h_source.html#l00097">97</a> of file <a class="el" href="cpl__virtualmem_8h_source.html">cpl_virtualmem.h</a>.</p>

</div>
</div>
<a class="anchor" id="aec0c6ca7bd8ad956b6f62faefdcc5b66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* CPLVirtualMemUnCachePageCbk)(<a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *ctxt, size_t nOffset, const void *pPageToBeEvicted, size_t nToBeEvicted, void *pUserData)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback triggered when a dirty mapped page is going to be freed. (saturation of cache, or termination of the virtual memory mapping).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctxt</td><td>virtual memory handle. </td></tr>
    <tr><td class="paramname">nOffset</td><td>offset of the page in the memory mapping. </td></tr>
    <tr><td class="paramname">pPageToBeEvicted</td><td>address of the page that will be flushed. Note that the address might be a temporary location, and not at <a class="el" href="cpl__virtualmem_8h.html#a25a74f5d89021660d2352eb17d1113fc">CPLVirtualMemGetAddr()</a> + nOffset. </td></tr>
    <tr><td class="paramname">nToBeEvicted</td><td>number of bytes of the page. </td></tr>
    <tr><td class="paramname">pUserData</td><td>user data that was passed to <a class="el" href="cpl__virtualmem_8h.html#a3ab2ce94850ef31458c65cb16ce828dc">CPLVirtualMemNew()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cpl__virtualmem_8h_source.html#l00088">88</a> of file <a class="el" href="cpl__virtualmem_8h_source.html">cpl_virtualmem.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="aeba7fc305d946740f9e88513220c73a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="cpl__virtualmem_8h.html#aeba7fc305d946740f9e88513220c73a1">CPLVirtualMemAccessMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access mode of a virtual memory mapping. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="aeba7fc305d946740f9e88513220c73a1ac449c40cb0760b72f362e2cf4cd3da79"></a>VIRTUALMEM_READONLY&#160;</td><td class="fielddoc">
<p>The mapping is meant at being read-only, but writes will not be prevented. Note that any content written will be lost. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aeba7fc305d946740f9e88513220c73a1a67628910ddcd5816bf230061adc45d97"></a>VIRTUALMEM_READONLY_ENFORCED&#160;</td><td class="fielddoc">
<p>The mapping is meant at being read-only, and this will be enforced through the operating system page protection mechanism. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aeba7fc305d946740f9e88513220c73a1aa6486140a01b52ef723a17a39f9e1169"></a>VIRTUALMEM_READWRITE&#160;</td><td class="fielddoc">
<p>The mapping is meant at being read-write, and modified pages can be saved thanks to the pfnUnCachePage callback </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="cpl__virtualmem_8h_source.html#l00100">100</a> of file <a class="el" href="cpl__virtualmem_8h_source.html">cpl_virtualmem.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a1fda6753fc13f3dc348605da8bce9c2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="cpl__port_8h.html#a42f5fd9b9df7d179918990cd3d7d6783">CPL_DLL</a> CPLGetPageSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the size of a page of virtual memory.</p>
<dl class="section return"><dt>Returns</dt><dd>the page size.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a23dca3961c27fceab73cb5b568c0e847"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__progress_8h.html#aae7d79c99462ba26b884decdbab4724d">int</a> <a class="el" href="cpl__port_8h.html#a42f5fd9b9df7d179918990cd3d7d6783">CPL_DLL</a> CPLIsVirtualMemFileMapAvailable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return if virtual memory mapping of a file is available.</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if virtual memory mapping of a file is available. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ab02ca8df117924498e82dd4baaf6e1f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="cpl__port_8h.html#a42f5fd9b9df7d179918990cd3d7d6783">CPL_DLL</a> CPLVirtualMemDeclareThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare that a thread will access a virtual memory mapping.</p>
<p>This function must be called by a thread that wants to access the content of a virtual memory mapping, except if the virtual memory mapping has been created with bSingleThreadUsage = TRUE.</p>
<p>This function must be paired with <a class="el" href="cpl__virtualmem_8h.html#a341e2a12a981a724b0a577a891e993f9">CPLVirtualMemUnDeclareThread()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctxt</td><td>context returned by <a class="el" href="cpl__virtualmem_8h.html#a3ab2ce94850ef31458c65cb16ce828dc">CPLVirtualMemNew()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="aa23ac6c1b9b0f185cc73a9c320180c9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> <a class="el" href="cpl__port_8h.html#a42f5fd9b9df7d179918990cd3d7d6783">CPL_DLL</a>* CPLVirtualMemDerivedNew </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *&#160;</td>
          <td class="paramname"><em>pVMemBase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a>&#160;</td>
          <td class="paramname"><em>nOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a>&#160;</td>
          <td class="paramname"><em>nSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#aba9d54d83138551ff3067d8e23d8448c">CPLVirtualMemFreeUserData</a>&#160;</td>
          <td class="paramname"><em>pfnFreeUserData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pCbkUserData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new virtual memory mapping derived from an other virtual memory mapping.</p>
<p>This may be usefull in case of creating mapping for pixel interleaved data.</p>
<p>The new mapping takes a reference on the base mapping.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pVMemBase</td><td>Base virtual memory mapping </td></tr>
    <tr><td class="paramname">nOffset</td><td>Offset in the base virtual memory mapping from which to start the new mapping. </td></tr>
    <tr><td class="paramname">nSize</td><td>Size of the base virtual memory mapping to expose in the the new mapping. </td></tr>
    <tr><td class="paramname">pfnFreeUserData</td><td>callback that is called when the object is destroyed. </td></tr>
    <tr><td class="paramname">pCbkUserData</td><td>user data passed to pfnFreeUserData. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a virtual memory object that must be freed by <a class="el" href="cpl__virtualmem_8h.html#a733490834e65cac877b01007e51f08cb">CPLVirtualMemFree()</a>, or NULL in case of failure.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a5109bc5b902ac637da108a8a4f7a2594"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> <a class="el" href="cpl__port_8h.html#a42f5fd9b9df7d179918990cd3d7d6783">CPL_DLL</a>* CPLVirtualMemFileMapNew </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#af1b1400e402360b38304de2b13d16c14">VSILFILE</a> *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a>&#160;</td>
          <td class="paramname"><em>nOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a>&#160;</td>
          <td class="paramname"><em>nLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#aeba7fc305d946740f9e88513220c73a1">CPLVirtualMemAccessMode</a>&#160;</td>
          <td class="paramname"><em>eAccessMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#aba9d54d83138551ff3067d8e23d8448c">CPLVirtualMemFreeUserData</a>&#160;</td>
          <td class="paramname"><em>pfnFreeUserData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pCbkUserData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new virtual memory mapping from a file.</p>
<p>The file must be a "real" file recognized by the operating system, and not a VSI extended virtual file.</p>
<p>In VIRTUALMEM_READWRITE mode, updates to the memory mapping will be written in the file.</p>
<p>On Linux AMD64 platforms, the maximum value for nLength is 128 TB. On Linux x86 platforms, the maximum value for nLength is 2 GB.</p>
<p>Only supported on Linux for now.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>Virtual file handle. </td></tr>
    <tr><td class="paramname">nOffset</td><td>Offset in the file to start the mapping from. </td></tr>
    <tr><td class="paramname">nLength</td><td>Length of the portion of the file to map into memory. </td></tr>
    <tr><td class="paramname">eAccessMode</td><td>Permission to use for the virtual memory mapping. This must be consistant with how the file has been opened. </td></tr>
    <tr><td class="paramname">pfnFreeUserData</td><td>callback that is called when the object is destroyed. </td></tr>
    <tr><td class="paramname">pCbkUserData</td><td>user data passed to pfnFreeUserData. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a virtual memory object that must be freed by <a class="el" href="cpl__virtualmem_8h.html#a733490834e65cac877b01007e51f08cb">CPLVirtualMemFree()</a>, or NULL in case of failure.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a733490834e65cac877b01007e51f08cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="cpl__port_8h.html#a42f5fd9b9df7d179918990cd3d7d6783">CPL_DLL</a> CPLVirtualMemFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free a virtual memory mapping.</p>
<p>The pointer returned by <a class="el" href="cpl__virtualmem_8h.html#a25a74f5d89021660d2352eb17d1113fc">CPLVirtualMemGetAddr()</a> will no longer be valid. If the virtual memory mapping was created with read/write permissions and that they are dirty (i.e. modified) pages, they will be flushed through the pfnUnCachePage callback before being freed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctxt</td><td>context returned by <a class="el" href="cpl__virtualmem_8h.html#a3ab2ce94850ef31458c65cb16ce828dc">CPLVirtualMemNew()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a0565635f915e3108d531194cc509def6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__virtualmem_8h.html#aeba7fc305d946740f9e88513220c73a1">CPLVirtualMemAccessMode</a> <a class="el" href="cpl__port_8h.html#a42f5fd9b9df7d179918990cd3d7d6783">CPL_DLL</a> CPLVirtualMemGetAccessMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the access mode of the virtual memory mapping.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctxt</td><td>context returned by <a class="el" href="cpl__virtualmem_8h.html#a3ab2ce94850ef31458c65cb16ce828dc">CPLVirtualMemNew()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the access mode of the virtual memory mapping.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a25a74f5d89021660d2352eb17d1113fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="cpl__port_8h.html#a42f5fd9b9df7d179918990cd3d7d6783">CPL_DLL</a>* CPLVirtualMemGetAddr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the pointer to the start of a virtual memory mapping.</p>
<p>The bytes in the range [p:p+CPLVirtualMemGetSize()-1] where p is the pointer returned by this function will be valid, until <a class="el" href="cpl__virtualmem_8h.html#a733490834e65cac877b01007e51f08cb">CPLVirtualMemFree()</a> is called.</p>
<p>Note that if a range of bytes used as an argument of a system call (such as read() or write()) contains pages that have not been "realized", the system call will fail with EFAULT. <a class="el" href="cpl__virtualmem_8h.html#ad5f5d5276f1cbe4c77637977476349f5">CPLVirtualMemPin()</a> can be used to work around this issue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctxt</td><td>context returned by <a class="el" href="cpl__virtualmem_8h.html#a3ab2ce94850ef31458c65cb16ce828dc">CPLVirtualMemNew()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the pointer to the start of a virtual memory mapping.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ad8fe1e9ab81d048c39655ebeb3fbc504"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="cpl__port_8h.html#a42f5fd9b9df7d179918990cd3d7d6783">CPL_DLL</a> CPLVirtualMemGetPageSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the page size associated to a virtual memory mapping.</p>
<p>The value returned will be at least <a class="el" href="cpl__virtualmem_8h.html#a1fda6753fc13f3dc348605da8bce9c2f">CPLGetPageSize()</a>, but potentially larger.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctxt</td><td>context returned by <a class="el" href="cpl__virtualmem_8h.html#a3ab2ce94850ef31458c65cb16ce828dc">CPLVirtualMemNew()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the page size</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a4203d033bae8e3810f0e0f9f64741429"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="cpl__port_8h.html#a42f5fd9b9df7d179918990cd3d7d6783">CPL_DLL</a> CPLVirtualMemGetSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the size of the virtual memory mapping.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctxt</td><td>context returned by <a class="el" href="cpl__virtualmem_8h.html#a3ab2ce94850ef31458c65cb16ce828dc">CPLVirtualMemNew()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of the virtual memory mapping.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="aebc227f9b7237e7a4ca7b284affffb98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__progress_8h.html#aae7d79c99462ba26b884decdbab4724d">int</a> <a class="el" href="cpl__port_8h.html#a42f5fd9b9df7d179918990cd3d7d6783">CPL_DLL</a> CPLVirtualMemIsAccessThreadSafe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return TRUE if this memory mapping can be accessed safely from concurrent threads.</p>
<p>The situation that can cause problems is when several threads try to access a page of the mapping that is not yet mapped.</p>
<p>The return value of this function depends on whether bSingleThreadUsage has been set of not in <a class="el" href="cpl__virtualmem_8h.html#a3ab2ce94850ef31458c65cb16ce828dc">CPLVirtualMemNew()</a> and/or the implementation.</p>
<p>On Linux, this will always return TRUE if bSingleThreadUsage = FALSE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctxt</td><td>context returned by <a class="el" href="cpl__virtualmem_8h.html#a3ab2ce94850ef31458c65cb16ce828dc">CPLVirtualMemNew()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if this memory mapping can be accessed safely from concurrent threads.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="aaba5873a189dc59339c85c46499202d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__progress_8h.html#aae7d79c99462ba26b884decdbab4724d">int</a> <a class="el" href="cpl__port_8h.html#a42f5fd9b9df7d179918990cd3d7d6783">CPL_DLL</a> CPLVirtualMemIsFileMapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return if the virtal memory mapping is a direct file mapping.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctxt</td><td>context returned by <a class="el" href="cpl__virtualmem_8h.html#a3ab2ce94850ef31458c65cb16ce828dc">CPLVirtualMemNew()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the virtal memory mapping is a direct file mapping.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a0aec86ac68ec821d1d48776a263fa0a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="cpl__port_8h.html#a42f5fd9b9df7d179918990cd3d7d6783">CPL_DLL</a> CPLVirtualMemManagerTerminate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cleanup any resource and handlers related to virtual memory.</p>
<p>This function must be called after the last CPLVirtualMem object has been freed.</p>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a3ab2ce94850ef31458c65cb16ce828dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> <a class="el" href="cpl__port_8h.html#a42f5fd9b9df7d179918990cd3d7d6783">CPL_DLL</a>* CPLVirtualMemNew </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nCacheSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nPageSizeHint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__progress_8h.html#aae7d79c99462ba26b884decdbab4724d">int</a>&#160;</td>
          <td class="paramname"><em>bSingleThreadUsage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#aeba7fc305d946740f9e88513220c73a1">CPLVirtualMemAccessMode</a>&#160;</td>
          <td class="paramname"><em>eAccessMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#a575c56435cea278a5bf98bf2c21e7b8f">CPLVirtualMemCachePageCbk</a>&#160;</td>
          <td class="paramname"><em>pfnCachePage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#aec0c6ca7bd8ad956b6f62faefdcc5b66">CPLVirtualMemUnCachePageCbk</a>&#160;</td>
          <td class="paramname"><em>pfnUnCachePage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#aba9d54d83138551ff3067d8e23d8448c">CPLVirtualMemFreeUserData</a>&#160;</td>
          <td class="paramname"><em>pfnFreeUserData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pCbkUserData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new virtual memory mapping.</p>
<p>This will reserve an area of virtual memory of size nSize, whose size might be potentially much larger than the physical memory available. Initially, no physical memory will be allocated. As soon as memory pages will be accessed, they will be allocated transparently and filled with the pfnCachePage callback. When the allowed cache size is reached, the least recently used pages will be unallocated.</p>
<p>On Linux AMD64 platforms, the maximum value for nSize is 128 TB. On Linux x86 platforms, the maximum value for nSize is 2 GB.</p>
<p>Only supported on Linux for now.</p>
<p>Note that on Linux, this function will install a SIGSEGV handler. The original handler will be restored by <a class="el" href="cpl__virtualmem_8h.html#a0aec86ac68ec821d1d48776a263fa0a4">CPLVirtualMemManagerTerminate()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nSize</td><td>size in bytes of the virtual memory mapping. </td></tr>
    <tr><td class="paramname">nCacheSize</td><td>size in bytes of the maximum memory that will be really allocated (must ideally fit into RAM). </td></tr>
    <tr><td class="paramname">nPageSizeHint</td><td>hint for the page size. Must be a multiple of the system page size, returned by <a class="el" href="cpl__virtualmem_8h.html#a1fda6753fc13f3dc348605da8bce9c2f">CPLGetPageSize()</a>. Minimum value is generally 4096. Might be set to 0 to let the function determine a default page size. </td></tr>
    <tr><td class="paramname">bSingleThreadUsage</td><td>set to TRUE if there will be no concurrent threads that will access the virtual memory mapping. This can optimize performance a bit. </td></tr>
    <tr><td class="paramname">eAccessMode</td><td>permission to use for the virtual memory mapping. </td></tr>
    <tr><td class="paramname">pfnCachePage</td><td>callback triggered when a still unmapped page of virtual memory is accessed. The callback has the responsibility of filling the page with relevant values. </td></tr>
    <tr><td class="paramname">pfnUnCachePage</td><td>callback triggered when a dirty mapped page is going to be freed (saturation of cache, or termination of the virtual memory mapping). Might be NULL. </td></tr>
    <tr><td class="paramname">pfnFreeUserData</td><td>callback that can be used to free pCbkUserData. Might be NULL </td></tr>
    <tr><td class="paramname">pCbkUserData</td><td>user data passed to pfnCachePage and pfnUnCachePage.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a virtual memory object that must be freed by <a class="el" href="cpl__virtualmem_8h.html#a733490834e65cac877b01007e51f08cb">CPLVirtualMemFree()</a>, or NULL in case of failure.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ad5f5d5276f1cbe4c77637977476349f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="cpl__port_8h.html#a42f5fd9b9df7d179918990cd3d7d6783">CPL_DLL</a> CPLVirtualMemPin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__progress_8h.html#aae7d79c99462ba26b884decdbab4724d">int</a>&#160;</td>
          <td class="paramname"><em>bWriteOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make sure that a region of virtual memory will be realized.</p>
<p>Calling this function is not required, but might be usefull when debugging a process with tools like gdb or valgrind that do not naturally like segmentation fault signals.</p>
<p>It is also needed when wanting to provide part of virtual memory mapping to a system call such as read() or write(). If read() or write() is called on a memory region not yet realized, the call will fail with EFAULT.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctxt</td><td>context returned by <a class="el" href="cpl__virtualmem_8h.html#a3ab2ce94850ef31458c65cb16ce828dc">CPLVirtualMemNew()</a>. </td></tr>
    <tr><td class="paramname">pAddr</td><td>the memory region to pin. </td></tr>
    <tr><td class="paramname">nSize</td><td>the size of the memory region. </td></tr>
    <tr><td class="paramname">bWriteOp</td><td>set to TRUE if the memory are will be accessed in write mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a341e2a12a981a724b0a577a891e993f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="cpl__port_8h.html#a42f5fd9b9df7d179918990cd3d7d6783">CPL_DLL</a> CPLVirtualMemUnDeclareThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__virtualmem_8h.html#aac693188a82d797c5a651f275fddab82">CPLVirtualMem</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare that a thread will stop accessing a virtual memory mapping.</p>
<p>This function must be called by a thread that will no longer access the content of a virtual memory mapping, except if the virtual memory mapping has been created with bSingleThreadUsage = TRUE.</p>
<p>This function must be paired with <a class="el" href="cpl__virtualmem_8h.html#ab02ca8df117924498e82dd4baaf6e1f7">CPLVirtualMemDeclareThread()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctxt</td><td>context returned by <a class="el" href="cpl__virtualmem_8h.html#a3ab2ce94850ef31458c65cb16ce828dc">CPLVirtualMemNew()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jun 11 2014 21:19:11 for OGR2GUI x64 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
